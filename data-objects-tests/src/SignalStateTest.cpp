#include <boost/test/unit_test.hpp>
#include <boost/make_shared.hpp>
#include <boost/asio/streambuf.hpp>
#include <boost/lexical_cast.hpp>

#include <iostream>
#include <iterator>
#include <iomanip>
#include <ctime>
#include <cmath>
#include <limits>

#include "SignalState.h"

using namespace std;
using namespace boost;
using namespace DataObjects;

BOOST_AUTO_TEST_SUITE( SignalStateTest )

bool print_streambuf(boost::asio::streambuf& sb) {
  std::size_t size = sb.size();
  uint8_t buff[size];
  sb.sgetn(reinterpret_cast<char*>(buff), sizeof(buff));
  for(std::size_t i = 0; i != size; ++i) {
	  std::cout << "0x"<< std::hex << std::setw(2) << std::setfill('0')
		  << (0xff& buff[i]) << ", ";
  }
  std::cout << std::endl;
  return true;
}

class MyBooleanListener : public StateListener {
 public:
  typedef boost::shared_ptr<MyBooleanListener> Ptr;

  MyBooleanListener() : stateChangeCalled(false) { }
  virtual ~MyBooleanListener() { }

  void stateChanged(StateEventPtr se) {
    stateChangeCalled = true;

    uint8_t expected[] = {
      0x02, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00,
      0x02, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x01
    };

    asio::streambuf sb;
    se->store(sb);
    //print_streambuf(sb);

    std::size_t length =  sb.size();
    BOOST_CHECK_EQUAL(length, sizeof(expected));

    uint8_t buff[length];
    sb.sgetn(reinterpret_cast<char*>(buff), sizeof(buff));

    for(std::size_t i = 0; i != length; ++i) {
      if(i > 0 && i < 9) continue;
      BOOST_CHECK_EQUAL(buff[i], expected[i]);
    }
  }

  bool isStateChanged() const {
    return stateChangeCalled;
  }
 private:
  bool stateChangeCalled;
};

BOOST_AUTO_TEST_CASE( testSaveSignalId ) {
  uint8_t expected[] = {
    0x17, 0x00, 0x00, 0x00, 0x32,
    0x30, 0x31, 0x36, 0x2d, 0x30,
    0x36, 0x2d, 0x30, 0x36, 0x20,
    0x30, 0x30, 0x3a, 0x30, 0x30,
    0x3a, 0x30, 0x30, 0x2e, 0x30,
    0x30, 0x30
  };
  asio::streambuf sb;
  SignalId id("2016-06-06 00:00:00.000");
  id.store(sb);

  std::size_t length = sb.size();
  BOOST_CHECK_EQUAL(length, sizeof(expected));

  uint8_t buff[length];
  sb.sgetn(reinterpret_cast<char*>(buff), sizeof(buff));

  for(std::size_t i = 0; i != length; ++i) {
    BOOST_CHECK_EQUAL(buff[i], expected[i]);
  }
}

BOOST_AUTO_TEST_CASE( testLoadSignalId ) {
  uint8_t expected[] = {
    0x17, 0x00, 0x00, 0x00, 0x32,
    0x30, 0x31, 0x36, 0x2d, 0x30,
    0x36, 0x2d, 0x30, 0x36, 0x20,
    0x30, 0x30, 0x3a, 0x30, 0x30,
    0x3a, 0x30, 0x30, 0x2e, 0x30,
    0x30, 0x30
  };
  asio::streambuf sb;
  sb.sputn(reinterpret_cast<char*>(&expected), sizeof(expected));

  SignalId id;
  id.load(sb);

  BOOST_CHECK_EQUAL(id.getValue(), "2016-06-06 00:00:00.000");
}

BOOST_AUTO_TEST_CASE( testSaveBooleanState ) {
  uint8_t expected[] = {
    0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01
  };
  BooleanState bs;
  bs.setValue(true);

  asio::streambuf sb;
  bs.store(sb);

  std::size_t length =  sb.size();
  BOOST_CHECK_EQUAL(length, sizeof(expected));

  uint8_t buff[length];
  sb.sgetn(reinterpret_cast<char*>(buff), sizeof(buff));

  for(std::size_t i = 0; i != length; ++i) {
    if(i > 0 && i < 9) continue;
    BOOST_CHECK_EQUAL(buff[i], expected[i]);
  }
}

BOOST_AUTO_TEST_CASE( testLoadBooleanState ) {
  uint8_t expected[] = {
    0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01
  };

  asio::streambuf sb;
  sb.sputn(reinterpret_cast<char*>(&expected), sizeof(expected));

  BooleanState bs;
  bs.load(sb);

  BOOST_CHECK_EQUAL(bs.getValue(), true);
}

BOOST_AUTO_TEST_CASE( testSaveAnalogState ) {
  uint8_t expected[] = {
    0x01, 0xd1, 0x44, 0x55, 0x57,
    0x00, 0x00, 0x00, 0x00, 0x90,
    0xf7, 0xaa, 0x95, 0x09, 0xbf,
    0x05, 0x40
  };
  AnalogState as;
  as.setValue(2.71828);

  asio::streambuf sb;
  as.store(sb);

  std::size_t length =  sb.size();
  BOOST_CHECK_EQUAL(length, sizeof(expected));

  uint8_t buff[length];
  sb.sgetn(reinterpret_cast<char*>(buff), sizeof(buff));

  for(std::size_t i = 0; i != length; ++i) {
    if(i > 0 && i < 9) continue;
    BOOST_CHECK_EQUAL(buff[i], expected[i]);
  }
}

BOOST_AUTO_TEST_CASE( testLoadAnalogState ) {
  uint8_t expected[] = {
    0x01, 0xd1, 0x44, 0x55, 0x57,
    0x00, 0x00, 0x00, 0x00, 0x90,
    0xf7, 0xaa, 0x95, 0x09, 0xbf,
    0x05, 0x40
  };
  asio::streambuf sb;
  sb.sputn(reinterpret_cast<char*>(&expected), sizeof(expected));
  
  AnalogState as;
  as.load(sb);

  std::size_t length =  sb.size();
  BOOST_CHECK_EQUAL(as.getValue(), 2.71828); // FIXME: This is not good.
  BOOST_CHECK(std::fabs(as.getValue() - 2.71828) < std::numeric_limits<double>::min());
}

BOOST_AUTO_TEST_CASE( testSaveStringState ) {
  uint8_t expected[] = {
    0x03, 0x84, 0x49, 0x55, 0x57, 
    0x00, 0x00, 0x00, 0x00, 0x07, 
    0x00, 0x00, 0x00, 0x32, 0x2e, 
    0x37, 0x31, 0x38, 0x32, 0x38
  };
  StringState ss;
  ss.setValue("2.71828");

  asio::streambuf sb;
  ss.store(sb);

  std::size_t length =  sb.size();
  BOOST_CHECK_EQUAL(length, sizeof(expected));

  uint8_t buff[length];
  sb.sgetn(reinterpret_cast<char*>(buff), sizeof(buff));

  for(std::size_t i = 0; i != length; ++i) {
	  if(i > 0 && i < 9) continue;
	  BOOST_CHECK_EQUAL(buff[i], expected[i]);
  }
}

BOOST_AUTO_TEST_CASE( testLoadStringState ) {
  uint8_t expected[] = {
    0x03, 0x84, 0x49, 0x55, 0x57,
    0x00, 0x00, 0x00, 0x00, 0x07,
    0x00, 0x00, 0x00, 0x32, 0x2e,
    0x37, 0x31, 0x38, 0x32, 0x38
  };
  asio::streambuf sb;
  sb.sputn(reinterpret_cast<char*>(&expected), sizeof(expected));

  StringState ss;
  ss.load(sb);

  BOOST_CHECK_EQUAL(ss.getValue(), "2.71828");
}

BOOST_AUTO_TEST_CASE( testSaveStateEvent ) {
  BooleanState bs;
  MyBooleanListener::Ptr l = boost::make_shared<MyBooleanListener>();
  bs.addChangeListener(l);
  bs.setValue(true);

  BOOST_CHECK_EQUAL(l->isStateChanged(), true);
}

BOOST_AUTO_TEST_CASE( testLoadStateEvent ) {
  uint8_t expected[] = {
    0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01
  };
  asio::streambuf sb;
  sb.sputn(reinterpret_cast<char*>(&expected), sizeof(expected));
 
  StateEvent se;
  se.load(sb);


  BOOST_CHECK_EQUAL(se.getBefore()->getType(), DI);
  BOOST_CHECK_EQUAL(se.getAfter()->getType(), DI);

  BOOST_CHECK_EQUAL(se.getBefore()->getType(), DI);
  BOOST_CHECK_EQUAL(se.getAfter()->getType(), DI);
}

BOOST_AUTO_TEST_CASE( testSaveGetStateRequest ) {
  uint8_t expected[] = {
    0x05, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x30, 0x01, 
    0x00, 0x00, 0x00, 0x31, 0x01, 
    0x00, 0x00, 0x00, 0x32, 0x01, 
    0x00, 0x00, 0x00, 0x33, 0x01, 
    0x00, 0x00, 0x00, 0x34
  };

  GetStateRequest request;
  for(int i = 0; i < 5; ++i) {
    SignalId id(boost::lexical_cast<std::string>(i));
    request.addSignalId(id);
  }
  boost::asio::streambuf sb;
  request.store(sb);
  for(std::size_t i = 0; i != sizeof(expected); ++i) {
    uint8_t c = sb.sbumpc();
    BOOST_CHECK_EQUAL(c, expected[i]);
  }
}

BOOST_AUTO_TEST_CASE( testLoadGetStateRequest ) {
  uint8_t expected[] = {
    0x05, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x30, 0x01, 
    0x00, 0x00, 0x00, 0x31, 0x01, 
    0x00, 0x00, 0x00, 0x32, 0x01, 
    0x00, 0x00, 0x00, 0x33, 0x01, 
    0x00, 0x00, 0x00, 0x34
  };
  
  boost::asio::streambuf sb;
  sb.sputn(reinterpret_cast<char*>(&expected), sizeof(expected));

  GetStateRequest request;
  request.load(sb);
  GetStateRequest::SignalIds ids = request.getSignalIds();
  int i = 0;
  for(auto& id : ids) {
    BOOST_CHECK_EQUAL(id.getValue(), boost::lexical_cast<std::string>(i++));
  }
}

BOOST_AUTO_TEST_CASE( testSaveGetStateResponse ) {
  uint8_t expected[] = {
    0x0a, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x30, 0x01, 
    0x6d, 0x30, 0x59, 0x57, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xf0, 
    0x3f, 0x01, 0x00, 0x00, 0x00, 
    0x31, 0x01, 0x6d, 0x30, 0x59, 
    0x57, 0x00, 0x00, 0x00, 0x00, 
    0x6a, 0xbc, 0x74, 0x93, 0x18, 
    0x04, 0xf0, 0x3f, 0x01, 0x00, 
    0x00, 0x00, 0x32, 0x01, 0x6d, 
    0x30, 0x59, 0x57, 0x00, 0x00, 
    0x00, 0x00, 0xd5, 0x78, 0xe9, 
    0x26, 0x31, 0x08, 0xf0, 0x3f, 
    0x01, 0x00, 0x00, 0x00, 0x33, 
    0x01, 0x6d, 0x30, 0x59, 0x57, 
    0x00, 0x00, 0x00, 0x00, 0x3f, 
    0x35, 0x5e, 0xba, 0x49, 0x0c, 
    0xf0, 0x3f, 0x01, 0x00, 0x00, 
    0x00, 0x34, 0x01, 0x6d, 0x30, 
    0x59, 0x57, 0x00, 0x00, 0x00, 
    0x00, 0xaa, 0xf1, 0xd2, 0x4d, 
    0x62, 0x10, 0xf0, 0x3f, 0x01, 
    0x00, 0x00, 0x00, 0x35, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x36, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x37, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x38, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x39, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01
  };

  GetStateResponse response;
  for(int i = 0; i < 5; ++i) {
    SignalId id(boost::lexical_cast<std::string>(i));
    AnalogState::Ptr as = boost::make_shared<AnalogState>();
    as->setValue(1.0 + 0.001 * i);
    response.addSignal(id, as);
  }
  for(int i = 5; i < 10; ++i) {
    SignalId id(boost::lexical_cast<std::string>(i));
    BooleanState::Ptr bs = boost::make_shared<BooleanState>();
    bs->setValue(true);
    response.addSignal(id, bs);
  }
  boost::asio::streambuf sb;
  response.store(sb);
  for(std::size_t i = 0; i != sizeof(expected); ++i) {
    uint8_t c = sb.sbumpc();
    BOOST_CHECK_EQUAL(c, expected[i]);
  }
}

BOOST_AUTO_TEST_CASE( testLoadGetStateResponse ) {
  uint8_t expected[] = {
    0x0a, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x30, 0x01, 
    0x6d, 0x30, 0x59, 0x57, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xf0, 
    0x3f, 0x01, 0x00, 0x00, 0x00, 
    0x31, 0x01, 0x6d, 0x30, 0x59, 
    0x57, 0x00, 0x00, 0x00, 0x00, 
    0x6a, 0xbc, 0x74, 0x93, 0x18, 
    0x04, 0xf0, 0x3f, 0x01, 0x00, 
    0x00, 0x00, 0x32, 0x01, 0x6d, 
    0x30, 0x59, 0x57, 0x00, 0x00, 
    0x00, 0x00, 0xd5, 0x78, 0xe9, 
    0x26, 0x31, 0x08, 0xf0, 0x3f, 
    0x01, 0x00, 0x00, 0x00, 0x33, 
    0x01, 0x6d, 0x30, 0x59, 0x57, 
    0x00, 0x00, 0x00, 0x00, 0x3f, 
    0x35, 0x5e, 0xba, 0x49, 0x0c, 
    0xf0, 0x3f, 0x01, 0x00, 0x00, 
    0x00, 0x34, 0x01, 0x6d, 0x30, 
    0x59, 0x57, 0x00, 0x00, 0x00, 
    0x00, 0xaa, 0xf1, 0xd2, 0x4d, 
    0x62, 0x10, 0xf0, 0x3f, 0x01, 
    0x00, 0x00, 0x00, 0x35, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x36, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x37, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x38, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x39, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01
  };

  boost::asio::streambuf sb;
  sb.sputn(reinterpret_cast<char*>(&expected), sizeof(expected));
  GetStateResponse response;
  response.load(sb);

  for(int i = 0; i < 5; ++i) {
    SignalId id(boost::lexical_cast<std::string>(i));
    AnalogState::Ptr as = boost::dynamic_pointer_cast<AnalogState>(response.getSignal(id));
    BOOST_CHECK_EQUAL(as->getValue(), (1.0 + 0.001 * i));
  }
  for(int i = 5; i < 10; ++i) {
    SignalId id(boost::lexical_cast<std::string>(i));
    BooleanState::Ptr bs = boost::dynamic_pointer_cast<BooleanState>(response.getSignal(id));
    BOOST_CHECK_EQUAL(bs->getValue(), true);
  }
}

BOOST_AUTO_TEST_CASE( testSaveSetStateRequest ) {
  uint8_t expected[] = {
    0x0a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x30, 0x01, 
    0x35, 0x3f, 0x59, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f, 0x01, 0x00, 0x00, 0x00, 
    0x31, 0x01, 0x35, 0x3f, 0x59, 0x57, 0x00, 0x00, 0x00, 0x00, 
    0x6a, 0xbc, 0x74, 0x93, 0x18, 0x04, 0xf0, 0x3f, 0x01, 0x00, 
    0x00, 0x00, 0x32, 0x01, 0x35, 0x3f, 0x59, 0x57, 0x00, 0x00, 
    0x00, 0x00, 0xd5, 0x78, 0xe9, 0x26, 0x31, 0x08, 0xf0, 0x3f, 
    0x01, 0x00, 0x00, 0x00, 0x33, 0x01, 0x35, 0x3f, 0x59, 0x57, 
    0x00, 0x00, 0x00, 0x00, 0x3f, 0x35, 0x5e, 0xba, 0x49, 0x0c, 
    0xf0, 0x3f, 0x01, 0x00, 0x00, 0x00, 0x34, 0x01, 0x35, 0x3f, 
    0x59, 0x57, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xf1, 0xd2, 0x4d, 
    0x62, 0x10, 0xf0, 0x3f, 0x01, 0x00, 0x00, 0x00, 0x35, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x36, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x37, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x38, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x39, 0x02, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
  };

  SetStateRequest request;
  for(int i = 0; i < 5; ++i) {
    SignalId id(boost::lexical_cast<std::string>(i));
    AnalogState::Ptr as = boost::make_shared<AnalogState>();
    as->setValue(1.0 + 0.001 * i);
    request.addSignal(id, as);
  }
  for(int i = 5; i < 10; ++i) {
    SignalId id(boost::lexical_cast<std::string>(i));
    BooleanState::Ptr bs = boost::make_shared<BooleanState>();
    bs->setValue(true);
    request.addSignal(id, bs);
  }
  boost::asio::streambuf sb;
  request.store(sb);
  for(std::size_t i = 0; i != sizeof(expected); ++i) {
    uint8_t c = sb.sbumpc();
    BOOST_CHECK_EQUAL(c, expected[i]);
  }
}

BOOST_AUTO_TEST_CASE( testLoadSetStateRequest ) {

}

BOOST_AUTO_TEST_CASE( testSaveSetStateResponse ) {

}

BOOST_AUTO_TEST_CASE( testLoadSetStateResponse ) {

}

BOOST_AUTO_TEST_SUITE_END()

